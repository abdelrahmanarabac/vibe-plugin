# üèóÔ∏è Vibe Plugin: Comprehensive Architectural Analysis & Master Plan

> **Generated by:** Vibe CTO (System 2 Analysis)
> **Date:** 2026-01-22
> **Version:** 1.0.0
> **Scope:** Full Codebase Audit (UI, Infrastructure, Domain, Intelligence)

---

## üìã 1. Executive Summary

The Vibe Plugin is a sophisticated "Agentic Design System" tool that bridges Figma's creative environment with semantic engineering discipline. It successfully implements a **Hexagonal Architecture** (mostly), isolating the "Token Graph" (Domain) from the "Figma API" (Infrastructure).

However, as the feature set has grown (AI, Collections, Documentation), **Coupling** has begun to creep in. The `controller.ts` is becoming a "God Object", and the UI layer (`App.tsx`) knows too much about the backend mechanics.

This document serves as the **Grand Unified Schema** to correct these drifts and elevate the system to "Principal Architect" standards.

---

## üìÇ 2. File-by-File Analysis & Clean Code Status

An exhaustive review of the codebase was performed. Below is the functionality map and specific "Clean Code" recommendations for each critical file.

### üß† Core Domain (The "Brain")
| File | Role | Clean Code Status | Improvement Strategy |
| :--- | :--- | :--- | :--- |
| `src/core/TokenGraph.ts` | **The Single Source of Truth.** Manages nodes (Tokens) and edges (Dependencies). | ‚úÖ **Excellent.** Pure TS, no external dependencies. | Add **Strongly Typed Events** (e.g., `on('nodeAdded')`) so other modules can react without tight coupling. |
| `src/core/types.ts` | Defines the Ubiquitous Language (`TokenEntity`, `TokenType`). | ‚úÖ **Solid.** Clean interfaces. | Move `VariableScope` to a specific Figma infrastructure type file; keep Domain types pure W3C. |
| `src/core/schema/TokenSchema.ts` | Zod schemas for validation. | ‚úÖ **Good.** | Centralize all Zod schemas here (Input/Output sanitization). |

### ü§ñ Intelligence Modules (The "Mind")
| File | Role | Clean Code Status | Improvement Strategy |
| :--- | :--- | :--- | :--- |
| `IntentEngine.ts` | Router for User Queries (System 1 vs System 2). | ‚ö†Ô∏è **Leaky.** Hardcoded regex patterns. | **Configuration Driven.** Move regex patterns to a JSON config or specialized "LanguageModel" class. |
| `AgentCore.ts` | Orchestrates the "Think -> Act" loop. | ‚úÖ **clean.** Good usage of Dependency Injection (`IAIService`). | Implement a **State Machine** (Idle -> Thinking -> Validating) to make the flow observable by UI. |
| `SemanticIntelligence.ts` | Prompt Engineering & Parsing. | ‚úÖ **Efficient.** Surgical parsing is robust. | Extract Prompts to external template files (`.txt` or `.hbs`) to separate Code from Data. |
| `QualityGate.ts` | Validates Logic (Contrast, Naming). | ‚ö†Ô∏è **Hardcoded Heuristics.** `colord` logic is inline. | **Rule Pattern.** Create `IRule` interface. (`ContrastRule`, `NamingRule`). Allow dynamic rule loading. |
| `PerceptionEngine.ts` | Scans Figma Nodes -> Primitives. | ‚ö†Ô∏è **Rigid.** Recursive tree traversal is monolithic. | **Visitor Pattern.** Create `NodeVisitor` classes for different node types (TextVisitor, FrameVisitor). |

### üèõÔ∏è Governance & Collections (The "Laws")
| File | Role | Clean Code Status | Improvement Strategy |
| :--- | :--- | :--- | :--- |
| `VariableManager.ts` | Syncs Figma Variables <-> Graph. | ‚ùå **Hybrid.** Mixes Business Logic with Figma API calls. | **Repository Pattern.** Split into `IVariableRepository` (Interface) and `FigmaVariableRepository` (Impl). Logic goes to `SyncVariablesUseCase`. |
| `CollectionClassifier.ts` | Logic to guess Collection types. | ‚úÖ **Pure.** Excellent testable logic. | **Strategy Pattern.** Allow plugging in new classification strategies (e.g., "Machine Learning Classifier"). |
| `CollectionRenamer.ts` | Adapter for Classifier logic. | ‚úÖ **Good Adapter.** | Add **Atomic Rollback**. If one rename fails, how do we revert? |

### üîå Infrastructure (The "Plumbing")
| File | Role | Clean Code Status | Improvement Strategy |
| :--- | :--- | :--- | :--- |
| `controller.ts` | **The Entry Point.** Handles Messages. | ‚ùå **God Object.** Massive `switch` statement. | **Command Pattern.** Create `CommandRegistry`. Map `'SCAN_SELECTION'` -> `ScanCommand`. |
| `App.tsx` | **The UI Root.** | ‚ùå **Bloated.** Contains business logic (`handleCommand`). | **MVVM / Hooks.** Move all logic to `useMainController()`. UI should only Render. |
| `GeminiService.ts` | AI API Wrapper. | ‚úÖ **Solid.** Handles Retries well. | Add **Cache Layer**. Store expensive query results in `clientStorage` to save money/time. |

---

## üß© 3. The Plugin Schema (Architecture Design)

To solve the scale problem, we must move from a "Monolithic Controller" to a **Plugin-Based Architecture**.

### The "Capability" Interface
Every feature (Scanning, Renaming, Documentation) becomes a "Capability".

```typescript
// core/interfaces/ICapability.ts
export interface ICapability {
  readonly id: string;
  readonly commandId: string; // e.g., 'scan_selection'
  
  /**
   * Can this capability handle the current context?
   */
  canExecute(context: AgentContext): boolean;

  /**
   * The Execution Logic.
   * Returns a Result to be sent back to the UI.
   */
  execute(payload: any, context: AgentContext): Promise<Result<any>>;
}
```

### The New Controller (Router)
The `controller.ts` becomes a dumb router:

```typescript
// controller.ts
const registry = new CapabilityRegistry();
registry.register(new ScanCapability());
registry.register(new RenameCapability());
registry.register(new DocsCapability());

figma.ui.onmessage = async (msg) => {
  const handler = registry.get(msg.type);
  if (handler) {
    await handler.execute(msg.payload, context);
  }
}
```

---

## üöÄ 4. "Smart Agent" Evolution Plan

To make the project "Smarter" (True Agentic AI), we must implement **Context Awareness**.

### Phase 1: The "Context Vector"
Instead of sending just the "Selection", we send the **Design Context**.
*   **Spatial Awareness:** "This Rectangle is *inside* a Frame named 'Card'."
*   **Semantic Awareness:** "This text is 'Submit', so the rectangle is likely a 'Button'."

**Implementation:** Update `PerceptionEngine` to build a `TreeContext` object, not just a flat list of primitives.

### Phase 2: Self-Healing (The Immune System)
The Agent should run in the background (Observer Mode).
1.  **Listen:** `figma.on('documentchange')`.
2.  **Detect:** User detached a variable to verify a hex code.
3.  **Heal:** Agent notifies: "You used `#3B82F6`. Included in system as `primary-500`. Re-link?"

### Phase 3: "Intent Prediction"
When a user selects a layer, the Agent should **Pre-compute** likely actions.
*   *Selection:* `Frame (Auto-Layout, Padding: 16)`
*   *Prediction:* "This looks like a Card. Create Component?"
*   *UI:* Omnibox shows "‚ú® Create Component" as the top suggestion.

---

## üßπ 5. Clean Architecture & Code Strategy

### Rule #1: The Dependency Rule
*   `src/core` (Domain) imports NOTHING.
*   `src/modules` (Use Cases) imports `src/core`.
*   `src/ui` and `src/infra` import `src/modules`.
*   **NEVER** let `src/core` import `src/infra`.

### Rule #2: Testing Strategy
*   **Unit Tests:** Test `CollectionClassifier`, `TokenGraph`, `SemanticIntelligence` exhaustively (Coverage > 90%). These are pure logic.
*   **Integration Tests:** Mock `figma` global object to test `VariableManager`.

### Rule #3: "Screaming" Folder Structure
Current:
- `modules/governance` (Good)
- `modules/intelligence` (Good)

Proposed Additions:
- `modules/orchestration` (For the Command Registry)
- `modules/analytics` (For tracking usage stats)

---

## üíé 6. Implementation Checklist (Priority Matrix)

### üî¥ Critical Priority (Do First - Week 1)

**CP-1: Establish Foundation Interfaces**
- [ ] Create `src/core/interfaces/ICapability.ts`
- [ ] Create `src/core/interfaces/IFigmaAdapter.ts`
- [ ] Create `src/core/interfaces/IVariableRepository.ts`
- [ ] Create `src/shared/utils/Result.ts` (Result<T, E> pattern)
- **Risk:** All refactoring depends on these contracts
- **Time:** 1 day
- **Testing:** Type compilation only

**CP-2: Build Capability Registry**
- [ ] Create `src/core/CapabilityRegistry.ts`
- [ ] Create `src/core/AgentContext.ts`
- [ ] Add capability error types
- [ ] Write unit tests for registry
- **Risk:** This is the new controller backbone
- **Time:** 2 days
- **Testing:** 100% coverage required

**CP-3: Proof of Concept - First Capability**
- [ ] Implement `ScanSelectionCapability`
- [ ] Test in isolation (mock Figma)
- [ ] Integrate with existing UI
- [ ] Verify no regressions
- **Risk:** Validates entire pattern
- **Time:** 2 days
- **Testing:** E2E test in Figma

---

### üü° High Priority (Week 2-3)

**HP-1: Controller Refactor**
- [ ] Create new `controller.ts` using CapabilityRegistry
- [ ] Migrate 5 core commands to capabilities:
  * `SCAN_SELECTION` ‚Üí `ScanSelectionCapability`
  * `SYNC_GRAPH` ‚Üí `SyncGraphCapability`
  * `RENAME_COLLECTIONS` ‚Üí `RenameCollectionsCapability`
  * `GENERATE_DOCS` ‚Üí `GenerateDocsCapability`
  * `CREATE_VARIABLE` ‚Üí `CreateVariableCapability`
- [ ] Delete old switch statement
- [ ] Measure: Controller LOC should drop from 256 to <100
- **Risk:** Breaking existing features
- **Time:** 5 days
- **Testing:** Full regression suite

**HP-2: Repository Pattern Implementation**
- [ ] Create `FigmaVariableRepository.ts`
- [ ] Create `FigmaStorageAdapter.ts`
- [ ] Convert `VariableManager` to `SyncVariablesUseCase`
- [ ] Remove all `figma.*` calls from use cases
- **Risk:** Breaking variable sync
- **Time:** 3 days
- **Testing:** Mock repository, test use case in isolation

**HP-3: Event-Driven TokenGraph**
- [ ] Add `EventEmitter` to `TokenGraph`
- [ ] Emit events on `addNode`, `updateNode`, `deleteNode`
- [ ] Update UI to subscribe to graph events
- [ ] Remove manual state sync hacks
- **Risk:** UI re-render performance
- **Time:** 2 days
- **Testing:** Performance profiling

---

### üü¢ Medium Priority (Week 4-5)

**MP-1: AI Service Enhancement**
- [ ] Add caching layer to `GeminiService`
- [ ] Implement `CachedAIService` wrapper
- [ ] Store cache in `figma.clientStorage`
- [ ] Add cache expiration (7 days)
- **Benefit:** Reduce API costs 70%
- **Time:** 2 days
- **Testing:** Cache hit rate monitoring

**MP-2: PerceptionEngine v2**
- [ ] Add `TreeContext` type
- [ ] Scan parent/child relationships
- [ ] Detect semantic patterns (Button, Card)
- [ ] Return structured context, not flat list
- **Benefit:** Enables smart suggestions
- **Time:** 4 days
- **Testing:** Pattern recognition accuracy >80%

**MP-3: UI Refactor (MVVM)**
- [ ] Move `handleCommand` logic from `App.tsx` to `useMainController` hook
- [ ] Create `useTokenGraph` hook
- [ ] Create `useCapabilities` hook
- [ ] App.tsx should be <50 lines (pure render)
- **Benefit:** Testable UI logic
- **Time:** 3 days
- **Testing:** Storybook components

---

### üîµ Low Priority (Week 6+)

**LP-1: Self-Healing Agent**
- [ ] Implement `DocumentChangeObserver`
- [ ] Build detached variable detector
- [ ] Add proactive suggestions
- [ ] Background validation worker
- **Benefit:** Autonomous operation
- **Time:** 5 days
- **Testing:** Chaos testing

**LP-2: Developer Tools**
- [ ] Add debug panel
- [ ] Capability profiler
- [ ] Event stream viewer
- [ ] Export system snapshot
- **Benefit:** Easier debugging
- **Time:** 3 days

---

## üßπ 7. Technical Debt Cleanup ("The Kill List")

These files/patterns must be eliminated during refactoring:

### To Delete:
- [ ] `src/modules/ai/AIOrchestrator.ts` (Unused, replaced by direct GeminiService)
- [ ] `src/modules/ai/CommandParser.ts` (Deprecated, IntentEngine handles this)
- [ ] Inline `hexToRgb` in `controller.ts` (Move to `ColorUtils`)

### To Refactor:
- [ ] `App.tsx` - **Current:** 247 lines. **Target:** <50 lines
- [ ] `controller.ts` - **Current:** 256 lines. **Target:** <100 lines
- [ ] `IntentEngine.ts` - Extract regex to config file

### To Test:
- [ ] `CollectionClassifier.ts` - Pure logic, needs 100% coverage
- [ ] `TokenGraph.ts` - Core domain, needs 100% coverage
- [ ] `QualityGate.ts` - Validation rules, needs 90% coverage

---

## üìä 8. Success Metrics Dashboard

| Metric | Baseline | Target | How to Measure |
|:-------|:---------|:-------|:---------------|
| **Code Quality** | | | |
| Controller LOC | 256 | <100 | `wc -l controller.ts` |
| Average File Size | 150 | <120 | `find src -name "*.ts" \| xargs wc -l` |
| Type Safety | 85% | 100% | `tsc --strict --noEmit` |
| **Architecture** | | | |
| Domain Purity | 60% | 100% | No figma imports in `src/core` |
| Circular Dependencies | 3 | 0 | `madge --circular` |
| **Performance** | | | |
| Command Dispatch | N/A | <50ms | Performance.now() wrapper |
| UI Re-render Count | High | Low | React DevTools Profiler |
| AI Cache Hit Rate | 0% | 70% | Log cache hits/misses |
| **Testing** | | | |
| Unit Test Coverage | 0% | 90% | `npm run test:coverage` |
| E2E Tests | 0 | 15 | Count test files |

---

## üö® 9. Risk Mitigation Strategy

### High-Risk Changes:
1. **Controller Refactor**
   - **Risk:** Breaking all commands
   - **Mitigation:** Feature flags, gradual migration
   - **Rollback:** Keep old controller in `controller.legacy.ts`

2. **Repository Pattern**
   - **Risk:** Breaking variable sync
   - **Mitigation:** A/B testing in dev
   - **Rollback:** Interface allows swapping implementations

3. **Event-Driven Graph**
   - **Risk:** Memory leaks, performance issues
   - **Mitigation:** Profiling, cleanup on unmount
   - **Rollback:** Events are additive, can remove listeners

### Low-Risk Changes:
1. Adding interfaces (no runtime impact)
2. Creating new files (doesn't break existing)
3. Writing tests (only improves confidence)

---

## üíé 10. Final Recommendation

**Immediate Action (Today):**
1. Create `ICapability` interface
2. Create `CapabilityRegistry`
3. Implement `ScanSelectionCapability` as POC
4. Test in Figma, verify zero regressions

**This Week:**
1. Migrate 5 core commands to capabilities
2. Refactor `controller.ts`
3. Add `Result<T, E>` pattern
4. Write 10 unit tests

**This Month:**
1. Complete all High Priority tasks
2. Achieve 90% test coverage
3. Deploy v2.0 internally
4. Document all capabilities

**Success Criteria:**
- ‚úÖ `controller.ts` < 100 lines
- ‚úÖ Domain has 0 infrastructure imports
- ‚úÖ 90% test coverage
- ‚úÖ All existing features work identically

---

> **Path Forward**  
> This plan transforms Vibe Plugin from a **Monolithic Script** to a **Modular Platform**.  
> Every step is reversible, testable, and incrementally deliverable.  
> 
> **Next Document:** See `PLUGIN_SCHEMA.md` for complete technical specification.
